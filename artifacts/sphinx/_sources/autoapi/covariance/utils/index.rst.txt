:py:mod:`covariance.utils`
==========================

.. py:module:: covariance.utils


Module Contents
---------------


Functions
~~~~~~~~~

.. autoapisummary::

   covariance.utils.from_row_to_covariance
   covariance.utils.from_row_matrix_to_covariance
   covariance.utils.get_turnover
   covariance.utils.Gaussian_likelihood
   covariance.utils.get_posterior_probs
   covariance.utils.get_frob_change
   covariance.utils.get_ar_format
   covariance.utils.plot_ewma_log_likelihoods
   covariance.utils.plot_ecdf
   covariance.utils.get_metrics
   covariance.utils.get_yearly_garch_params
   covariance.utils.moving_average
   covariance.utils.get_hi
   covariance.utils.get_lo
   covariance.utils.get_pos
   covariance.utils.get_neg
   covariance.utils.get_features
   covariance.utils.get_R
   covariance.utils.get_V_hats
   covariance.utils.cp_get_log_likelihood
   covariance.utils.max_log_likelihood_const_L
   covariance.utils.max_log_likelihood_varying_L
   covariance.utils.max_log_likelihood
   covariance.utils.max_log_likelihood_const_theta
   covariance.utils.get_overtriangular
   covariance.utils.get_overtriangular_stack
   covariance.utils.get_vectorform
   covariance.utils.max_log_likelihood_varying_L2
   covariance.utils.get_opt_weights_new
   covariance.utils.get_opt_weights_old
   covariance.utils.get_realized_covs
   covariance.utils.get_realized_vars
   covariance.utils.from_cov_to_corr
   covariance.utils.get_realized_sizes
   covariance.utils.get_next_ewma
   covariance.utils.get_ewmas
   covariance.utils.get_r_tildes
   covariance.utils.get_cholesky
   covariance.utils.get_log_likelihood
   covariance.utils.get_avg_likelihood
   covariance.utils.get_daily_likelihood



.. py:function:: from_row_to_covariance(row, n)

   Convert upper diagonal part of covariance matrix to a covariance matrix


.. py:function:: from_row_matrix_to_covariance(M, n)

   Convert Tx(n(n+1)/2) matrix of upper diagonal parts of covariance matrices to a Txnxn matrix of covariance matrices


.. py:function:: get_turnover(ws)


.. py:function:: Gaussian_likelihood(x, Sigma, mu=None)

   Computes the Gaussian likelihood of x given mu and Sigma.


.. py:function:: get_posterior_probs(x, Sigmas, mus=None, weights=None)

   Computes the posterior probabilities of each Gaussian distribution given x.


.. py:function:: get_frob_change(X)

   Computes frobenius norm of change in X and divides by number of rows


.. py:function:: get_ar_format(X, l)

   Returns AR(l) representation of X


.. py:function:: plot_ewma_log_likelihoods(predictors, start_date, end_date=None, T_half=63, labels=None, with_opt=False)


.. py:function:: plot_ecdf(datas, labels=None)

   Compute ECDF for a one-dimensional array of measurements.


.. py:function:: get_metrics(log_likelihoods)

   param log_likelihoods: list of log likelihoods

   returns: metrics


.. py:function:: get_yearly_garch_params(R, update_freq=2)

   returns a dict of "yearly" GARCH parameters for each asset,
       strictly speaking updated every update_freq years


.. py:function:: moving_average(X, n)

   param R: pd.DataFrame of shape (T, n) where T is the number of time steps and n is the number of assets
   param n: window size

   returns the moving average of X with window size n


.. py:function:: get_hi(X, sigmas)

   return hi feature


.. py:function:: get_lo(X, sigmas)

   return lo feature


.. py:function:: get_pos(X)

   return positive part


.. py:function:: get_neg(X)

   return negative part


.. py:function:: get_features(R, val_end, n=8)

   feature engineers the data


.. py:function:: get_R(R_whitenened, Lt_invs)

   param R_whitenened: numpy array of shape (T, n, 1) where T is the number of time steps and n is the number of assets
       these are the realized returns over the T days
   param Lt_invs: numpy array of shape (T, n, n) where T is the number of time steps and n is the number of assets
       these are the inverse of the whitening matrices

   returns: numpy array of shape (T, n) where T is the number of time steps and n is the number of assets


.. py:function:: get_V_hats(vols)

   param vols: numpy array of shape (T, n) where T is the number of time steps and n is the number of assets
       these are the predicted volatilities over the T days

   returns: numpy array of shape (T, n, n) where T is the number of time steps and n is the number of assets
       these are the predicted diagonal volatility matrices over the T days


.. py:function:: cp_get_log_likelihood(r, Theta)

   param R: array of shape (n,1) where n is the number of assets
   param Theta: precision matrix of shape (n,n) where n is the number of assets

   returns: log likelihood of R given Theta


.. py:function:: max_log_likelihood_const_L(prob, w, Lt_params, Lt_times_R_vec_params, Lt_hat, Lt_times_R_vec, prob_num, ignore_dpp=False)

   param whiteners: array of shape (M, n, n) where M is the number of predictor candidates, and n is the number of assets
       whiteners[i] = Li^T, where Li*Li^T=Sigma_i, the precission matrix of the i-th predictor
   param R: numpy array of shape (T, n, 1) where T is the number of time steps and n is the number of assets
       these are the realized returns over the T days

   returns the weights that maximize the log likelihood of the data given M constant whiteners


.. py:function:: max_log_likelihood_varying_L(prob, w, Lt_params, Lt_times_R_vec_params, Lt_hat, Lt_times_R_vec, prob_num, ignore_dpp=False)

   param whiteners: array of shape (M, n, n) where M is the number of predictor candidates, and n is the number of assets
       whiteners[i] = Li^T, where Li*Li^T=Sigma_i, the precission matrix of the i-th predictor
   param R: numpy array of shape (T, n, 1) where T is the number of time steps and n is the number of assets
       these are the realized returns over the T days

   returns the weights that maximize the log likelihood of the data given M constant whiteners


.. py:function:: max_log_likelihood(prob, w, prec_params, prec_at_cov_params, precisions, prec_at_covs, prob_num)

   param precisions: numpy array of shape (T, M, n, n) where T is the number of time steps, M is the number of predictor candidates, and n is the number of assets
   param R: numpy array of shape (T, n, 1) where T is the number of time steps and n is the number of assets
       these are the realized returns over the T days


.. py:function:: max_log_likelihood_const_theta(prob, w, prec_params, prec_at_cov_params, precisions, prec_at_covs, prob_num)

   param precisions: array of shape (M, n, n) M is the number of predictor candidates, and n is the number of assets
   param R: numpy array of shape (T, n) where T is the number of time steps and n is the number of assets
       these are the realized returns over the T days

   returns the weights that maximize the log likelihood of the data given M constant precision matrices
       i.e., in comparison to max_log_likelihood, this function assumes that the precision matrices are constant over time t=1,2,...,T


.. py:function:: get_overtriangular(M)

   returns the upper triangular part of a matrix M (including the diagonal)


.. py:function:: get_overtriangular_stack(Ms)

   returns the upper triangular part of a list of matrices Ms (including the diagonal)        upper diagonals are returned as rows in a matrix


.. py:function:: get_vectorform(R)

   returns the form of R that is used to compute L^T * R elementwise


.. py:function:: max_log_likelihood_varying_L2(prob, w, P_param, onest_A_param, P, onest_A, prob_num, ignore_dpp=False)

   param whiteners: array of shape (M, n, n) where M is the number of predictor candidates, and n is the number of assets
       whiteners[i] = Li^T, where Li*Li^T=Sigma_i, the precission matrix of the i-th predictor
   param R: numpy array of shape (T, n, 1) where T is the number of time steps and n is the number of assets
       these are the realized returns over the T days

   returns the weights that maximize the log likelihood of the data given M constant whiteners


.. py:function:: get_opt_weights_new(model, likelihood_window=10, w_init=None, const_theta=None, const_L=None, turnover_cons=None)

   param model: Covariance predictor model
   param likelihood_window: number of past days to use to compute the log likelihood
   param w_init: initial weights to use for the convex optimization problem
   param const_theta: whether the precision matrices are constant over time or not


.. py:function:: get_opt_weights_old(model, t, prob, w, theta_params, likelihood_window=10, w_init=None, const_theta=True)

   Choose the weights to combine the inverse covariance matrices by solving the following convex problem:  what (constant) weights would have maximized the log likelihood on the last 'likelihood_window' days? This is a convex problem, so we can solve it with cvxpy.

   param model: Covariance predictor model
   param t: time step (pandas date-time object) for which we want to compute the optimal weights
   param prob: cvxpy problem object
   param w: cvxpy variable object
   param theta_params: array of cvxpy parameters for the precision matrix
   param likelihood_window: number of past days to use to compute the log likelihood


.. py:function:: get_realized_covs(R)

   param R: numpy array where rows are vector of asset returns for t=0,1,...
       R has shape (T, n) where T is the number of days and n is the number of assets

   returns: (numpy array) list of r_t*r_t' (matrix multiplication) for all days, i.e,
       "daily realized covariances"


.. py:function:: get_realized_vars(R)

   param R: numpy array where rows are vector of asset returns for t=0,1,...
       R has shape (T, n) where T is the number of days and n is the number of assets

   returns: (numpy array) list of diag(r_t^2) for all days, i.e,        "daily realized variances"


.. py:function:: from_cov_to_corr(Sigma)

   returns correlation matrix R corresponding to covariance matrix Sigma


.. py:function:: get_realized_sizes(R)

   param R: numpy array where rows are vector of asset returns for t=0,1,...
       R has shape (T, n) where T is the number of days and n is the number of assets

       returns: (numpy array) list of r_t^Tr_t for all days (t), i.e,
           "daily realized sizes"


.. py:function:: get_next_ewma(EWMA, y_last, t, beta)

   param EWMA: EWMA at time t-1
   param y_last: observation at time t-1
   param t: current time step
   param beta: EWMA exponential forgetting parameter

   returns: EWMA estimate at time t (note that this does not depend on y_t)


.. py:function:: get_ewmas(y, T_half)

   y: array with measurements for times t=1,2,...,T=len(y)
   T_half: EWMA half life

   returns: list of EWMAs for times t=2,3,...,T+1 = len(y)


   Note: We define EWMA_t as a function of the
   observations up to time t-1. This means that
   y = [y_1,y_2,...,y_T] (for some T), while
   EWMA = [EWMA_2, EWMA_3, ..., EWMA_{T+1}]
   This way we don't get a "look-ahead bias" in the EWMA


.. py:function:: get_r_tildes(R, Ws)

   param Ws: array of whitening matrices for t=1,2,..., (i.e. L^t, where LL^T=Sigma^-1)
   param R: array of returns to whiten for t=1,2,...,

   returns numpy array with r_tilde_hats as rows


.. py:function:: get_cholesky(Sigma_hats)

   returns: Cholesky (transpose) decomposition of Sigma_hat^-1 for each Sigma_hat in Sigma_hats, i.e.,
       LL^T = Sigma_hat^-1;
       Note: returns L^T


.. py:function:: get_log_likelihood(x, Sigma, mu=None)

   param x: numpy array of shape (n,1)
   param Sigma: numpy array of shape (n,n)
   param mu: numpy array of shape (n,1)
       if None, mu is set to zero vector

   returns: log-likelihood of x under multivariate normal distribution


.. py:function:: get_avg_likelihood(R, Sigma_hats)

   returns: (averaged) log-likelihood of observed returns R, under the Gaussian distribution
       with mean zero and covariances in Sigma_hats

   param R: rows are n-dimensinal return vectors for times t=1,...,T
   param Sigma_hats: array-like vector of corresponding covariance matrices


.. py:function:: get_daily_likelihood(R, Sigma_hats, in_parallel=False)

   returns: log-likelihood of observed returns R, under the Gaussian distribution
       with mean zero and covariances in Sigma_hats


