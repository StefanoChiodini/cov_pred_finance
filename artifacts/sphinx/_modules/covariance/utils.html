<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>covariance.utils &mdash; cvxsimulator Documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
    <link rel="shortcut icon" href="../../_static/logo.jpeg"/>
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> cvxsimulator
            <img src="../../_static/logo.jpeg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../license.html">License</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../autoapi/index.html">API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">cvxsimulator</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
      <li>covariance.utils</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for covariance.utils</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span> <span class="k">as</span> <span class="nn">mp</span>
<span class="kn">import</span> <span class="nn">cvxpy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">trange</span>
<span class="kn">from</span> <span class="nn">concurrent.futures</span> <span class="kn">import</span> <span class="n">ProcessPoolExecutor</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">arch</span> <span class="kn">import</span> <span class="n">arch_model</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>



<div class="viewcode-block" id="from_row_to_covariance"><a class="viewcode-back" href="../../autoapi/covariance/utils/index.html#covariance.utils.from_row_to_covariance">[docs]</a><span class="k">def</span> <span class="nf">from_row_to_covariance</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert upper diagonal part of covariance matrix to a covariance matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>

    <span class="c1"># set upper triangular part</span>
    <span class="n">upper_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">)),</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">Sigma</span><span class="p">[</span><span class="n">upper_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span>

    <span class="c1"># set lower triangular part</span>
    <span class="n">lower_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tril</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">)),</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">Sigma</span><span class="p">[</span><span class="n">lower_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">Sigma</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">lower_mask</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">Sigma</span></div>

<div class="viewcode-block" id="from_row_matrix_to_covariance"><a class="viewcode-back" href="../../autoapi/covariance/utils/index.html#covariance.utils.from_row_matrix_to_covariance">[docs]</a><span class="k">def</span> <span class="nf">from_row_matrix_to_covariance</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert Tx(n(n+1)/2) matrix of upper diagonal parts of covariance matrices to a Txnxn matrix of covariance matrices</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Sigmas</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
        <span class="n">Sigmas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">from_row_to_covariance</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">t</span><span class="p">],</span> <span class="n">n</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Sigmas</span><span class="p">)</span></div>

<div class="viewcode-block" id="get_turnover"><a class="viewcode-back" href="../../autoapi/covariance/utils/index.html#covariance.utils.get_turnover">[docs]</a><span class="k">def</span> <span class="nf">get_turnover</span><span class="p">(</span><span class="n">ws</span><span class="p">):</span>
        <span class="n">turnovers</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">ws</span><span class="p">)):</span>
            <span class="n">w_tm</span> <span class="o">=</span> <span class="n">ws</span><span class="p">[</span><span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">w_t</span> <span class="o">=</span> <span class="n">ws</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
            <span class="n">turnovers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">w_tm</span><span class="o">-</span><span class="n">w_t</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">turnovers</span><span class="p">)</span></div>


<div class="viewcode-block" id="Gaussian_likelihood"><a class="viewcode-back" href="../../autoapi/covariance/utils/index.html#covariance.utils.Gaussian_likelihood">[docs]</a><span class="k">def</span> <span class="nf">Gaussian_likelihood</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Sigma</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the Gaussian likelihood of x given mu and Sigma. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">mu</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">Sigma</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">Sigma</span><span class="p">)</span> <span class="o">@</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">mu</span><span class="p">))</span></div>

<div class="viewcode-block" id="get_posterior_probs"><a class="viewcode-back" href="../../autoapi/covariance/utils/index.html#covariance.utils.get_posterior_probs">[docs]</a><span class="k">def</span> <span class="nf">get_posterior_probs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Sigmas</span><span class="p">,</span> <span class="n">mus</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the posterior probabilities of each Gaussian distribution given x. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">mus</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Sigmas</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">n</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">Sigmas</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">Sigmas</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">probs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Sigmas</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Sigmas</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">probs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">Gaussian_likelihood</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Sigmas</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">mus</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">probs</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">probs</span><span class="p">)</span></div>

<span class="c1"># def get_Lt()</span>

<div class="viewcode-block" id="get_frob_change"><a class="viewcode-back" href="../../autoapi/covariance/utils/index.html#covariance.utils.get_frob_change">[docs]</a><span class="k">def</span> <span class="nf">get_frob_change</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes frobenius norm of change in X and divides by number of rows</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">X</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="get_ar_format"><a class="viewcode-back" href="../../autoapi/covariance/utils/index.html#covariance.utils.get_ar_format">[docs]</a><span class="k">def</span> <span class="nf">get_ar_format</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">l</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns AR(l) representation of X</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Initialize AR(l) representation</span>
    <span class="n">X_ar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">T</span><span class="o">-</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="o">*</span><span class="n">l</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
        <span class="n">X_ar</span><span class="p">[:,</span> <span class="n">i</span><span class="o">*</span><span class="n">n</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">T</span><span class="o">-</span><span class="n">l</span><span class="o">+</span><span class="n">i</span><span class="p">]</span>

    <span class="n">y_ar</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">l</span><span class="p">:]</span>
        
    <span class="k">return</span> <span class="n">X_ar</span><span class="p">,</span> <span class="n">y_ar</span></div>


<div class="viewcode-block" id="plot_ewma_log_likelihoods"><a class="viewcode-back" href="../../autoapi/covariance/utils/index.html#covariance.utils.plot_ewma_log_likelihoods">[docs]</a><span class="k">def</span> <span class="nf">plot_ewma_log_likelihoods</span><span class="p">(</span><span class="n">predictors</span><span class="p">,</span> <span class="n">start_date</span><span class="p">,</span> <span class="n">end_date</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">T_half</span><span class="o">=</span><span class="mi">63</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">with_opt</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

    <span class="k">if</span> <span class="n">end_date</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">end_date</span> <span class="o">=</span> <span class="n">predictors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">dates</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">predictors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">start_date</span><span class="p">:</span><span class="n">end_date</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

    <span class="n">log_likes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">predictor</span> <span class="ow">in</span> <span class="n">predictors</span><span class="p">:</span>
        <span class="n">log_likes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">predictor</span><span class="o">.</span><span class="n">get_log_likelihoods</span><span class="p">(</span><span class="n">start_date</span><span class="p">,</span> <span class="n">end_date</span><span class="p">))</span>

    <span class="n">ewma_log_likes</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">log_like</span> <span class="ow">in</span> <span class="n">log_likes</span><span class="p">:</span>
        <span class="n">ewma_log_likes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">get_ewmas</span><span class="p">(</span><span class="n">log_like</span><span class="p">,</span> <span class="n">T_half</span><span class="p">))</span>


    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ewma_log_like</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ewma_log_likes</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">with_opt</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">dates</span><span class="p">,</span> <span class="n">ewma_log_like</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">dates</span><span class="p">,</span> <span class="n">ewma_log_like</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    



    <span class="c1"># Place legend outside to right of plot</span>
    <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Make legend dots bigger</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">bbox_to_anchor</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper left&#39;</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span> <span class="n">scatterpoints</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">markerscale</span><span class="o">=</span><span class="mi">5</span><span class="p">);</span></div>

<div class="viewcode-block" id="plot_ecdf"><a class="viewcode-back" href="../../autoapi/covariance/utils/index.html#covariance.utils.plot_ecdf">[docs]</a><span class="k">def</span> <span class="nf">plot_ecdf</span><span class="p">(</span><span class="n">datas</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute ECDF for a one-dimensional array of measurements.&quot;&quot;&quot;</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">datas</span><span class="p">):</span>
        <span class="c1"># Number of data points: n</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="c1"># x-data for the ECDF: x</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="c1"># y-data for the ECDF: y</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span>

        <span class="k">if</span> <span class="n">labels</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

        <span class="c1"># Plot 5th and 10th percentile as dashed line</span>
        <span class="c1"># plt.plot(x, np.ones(n)*0.025, &#39;--&#39;, color=&#39;gray&#39;, label=&#39;2.5th percentile&#39;)</span>

        <span class="c1"># plt.plot(x, np.ones(n)*0.05, &#39;--&#39;, color=&#39;gray&#39;, label=&#39;5th percentile&#39;)</span>
        <span class="c1"># plt.plot(x, np.ones(n)*0.1, &#39;--&#39;, color=&#39;gray&#39;, label=&#39;10th percentile&#39;)</span>

    <span class="c1"># Put legend to right of plot</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;center left&#39;</span><span class="p">,</span> <span class="n">bbox_to_anchor</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">))</span></div>

<div class="viewcode-block" id="get_metrics"><a class="viewcode-back" href="../../autoapi/covariance/utils/index.html#covariance.utils.get_metrics">[docs]</a><span class="k">def</span> <span class="nf">get_metrics</span><span class="p">(</span><span class="n">log_likelihoods</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    param log_likelihoods: list of log likelihoods</span>

<span class="sd">    returns: metrics</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">log_likelihoods</span><span class="p">)</span>
    <span class="n">std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">log_likelihoods</span><span class="p">)</span>
    <span class="n">lowest</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">log_likelihoods</span><span class="p">)</span>

    <span class="c1"># 1st, 5th and 10th percentile</span>
    <span class="n">p1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">log_likelihoods</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">p5</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">log_likelihoods</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
    <span class="n">p10</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">log_likelihoods</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">avg</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">std</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">lowest</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">p5</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">p10</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span></div>

<div class="viewcode-block" id="get_yearly_garch_params"><a class="viewcode-back" href="../../autoapi/covariance/utils/index.html#covariance.utils.get_yearly_garch_params">[docs]</a><span class="k">def</span> <span class="nf">get_yearly_garch_params</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">update_freq</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    returns a dict of &quot;yearly&quot; GARCH parameters for each asset,</span>
<span class="sd">        strictly speaking updated every update_freq years</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">window_size</span> <span class="o">=</span> <span class="n">update_freq</span><span class="o">*</span><span class="mi">250</span>

    <span class="c1"># Create a list of years in the data</span>
    <span class="n">years</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">year</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>

    <span class="n">all_params</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">asset</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
        <span class="c1"># Initialize an empty dict to store the results of the rolling window estimation</span>
        <span class="n">yearly_params</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Loop over the years</span>
        <span class="k">for</span> <span class="n">year</span> <span class="ow">in</span> <span class="n">years</span><span class="p">[</span><span class="n">update_freq</span><span class="p">:]:</span>
            <span class="c1"># Get the data for the two previous years</span>
            <span class="n">data_temp</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="n">R</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">year</span> <span class="o">&lt;</span> <span class="n">year</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> 
            <span class="n">am</span> <span class="o">=</span> <span class="n">arch_model</span><span class="p">(</span><span class="n">data_temp</span><span class="p">,</span> <span class="n">vol</span><span class="o">=</span><span class="s1">&#39;GARCH&#39;</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="s1">&#39;Normal&#39;</span><span class="p">,</span> <span class="n">rescale</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">am</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">disp</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">yearly_params</span><span class="p">[</span><span class="n">year</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">params</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">update_freq</span><span class="p">):</span>
            <span class="n">yearly_params</span><span class="p">[</span><span class="n">years</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">yearly_params</span><span class="p">[</span><span class="n">years</span><span class="p">[</span><span class="n">update_freq</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span>

        <span class="n">all_params</span><span class="p">[</span><span class="n">asset</span><span class="p">]</span> <span class="o">=</span> <span class="n">yearly_params</span>

    <span class="k">return</span> <span class="n">all_params</span></div>


<div class="viewcode-block" id="moving_average"><a class="viewcode-back" href="../../autoapi/covariance/utils/index.html#covariance.utils.moving_average">[docs]</a><span class="k">def</span> <span class="nf">moving_average</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    param R: pd.DataFrame of shape (T, n) where T is the number of time steps and n is the number of assets</span>
<span class="sd">    param n: window size</span>

<span class="sd">    returns the moving average of X with window size n</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">ma_part</span> <span class="o">=</span> <span class="p">(</span><span class="n">ret</span><span class="p">[</span><span class="n">n</span><span class="p">:]</span> <span class="o">-</span> <span class="n">ret</span><span class="p">[:</span><span class="o">-</span><span class="n">n</span><span class="p">])</span> <span class="o">/</span> <span class="n">n</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">ret</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span><span class="o">/</span><span class="n">n</span><span class="p">,</span> <span class="n">ma_part</span><span class="p">])</span></div>


<div class="viewcode-block" id="get_hi"><a class="viewcode-back" href="../../autoapi/covariance/utils/index.html#covariance.utils.get_hi">[docs]</a><span class="k">def</span> <span class="nf">get_hi</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">sigmas</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    return hi feature</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">((</span><span class="n">X</span> <span class="o">-</span> <span class="n">sigmas</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="get_lo"><a class="viewcode-back" href="../../autoapi/covariance/utils/index.html#covariance.utils.get_lo">[docs]</a><span class="k">def</span> <span class="nf">get_lo</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">sigmas</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    return lo feature</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">X</span> <span class="o">-</span> <span class="n">sigmas</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="get_pos"><a class="viewcode-back" href="../../autoapi/covariance/utils/index.html#covariance.utils.get_pos">[docs]</a><span class="k">def</span> <span class="nf">get_pos</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    return positive part </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="get_neg"><a class="viewcode-back" href="../../autoapi/covariance/utils/index.html#covariance.utils.get_neg">[docs]</a><span class="k">def</span> <span class="nf">get_neg</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    return negative part</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="o">-</span><span class="n">X</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_features"><a class="viewcode-back" href="../../autoapi/covariance/utils/index.html#covariance.utils.get_features">[docs]</a><span class="k">def</span> <span class="nf">get_features</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">val_end</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">8</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    feature engineers the data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">values</span>

    <span class="c1">### Define features</span>
    <span class="n">sigmas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">X</span><span class="p">[:</span><span class="n">val_end</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">hi</span> <span class="o">=</span> <span class="n">get_hi</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">sigmas</span><span class="p">)</span>
    <span class="n">lo</span> <span class="o">=</span> <span class="n">get_lo</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">sigmas</span><span class="p">)</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">get_pos</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="n">neg</span> <span class="o">=</span> <span class="n">get_neg</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

    <span class="n">ma2</span> <span class="o">=</span> <span class="n">moving_average</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">sigmas2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">ma2</span><span class="p">[:</span><span class="n">val_end</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">hi2</span> <span class="o">=</span> <span class="n">get_hi</span><span class="p">(</span><span class="n">ma2</span><span class="p">,</span> <span class="n">sigmas2</span><span class="p">)</span>
    <span class="n">lo2</span> <span class="o">=</span> <span class="n">get_lo</span><span class="p">(</span><span class="n">ma2</span><span class="p">,</span> <span class="n">sigmas2</span><span class="p">)</span>
    <span class="n">pos2</span> <span class="o">=</span> <span class="n">get_pos</span><span class="p">(</span><span class="n">ma2</span><span class="p">)</span>
    <span class="n">neg2</span> <span class="o">=</span> <span class="n">get_neg</span><span class="p">(</span><span class="n">ma2</span><span class="p">)</span>

    <span class="n">ma4</span> <span class="o">=</span> <span class="n">moving_average</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="n">sigmas4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">ma4</span><span class="p">[:</span><span class="n">val_end</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">hi4</span> <span class="o">=</span> <span class="n">get_hi</span><span class="p">(</span><span class="n">ma4</span><span class="p">,</span> <span class="n">sigmas4</span><span class="p">)</span>
    <span class="n">lo4</span> <span class="o">=</span> <span class="n">get_lo</span><span class="p">(</span><span class="n">ma4</span><span class="p">,</span> <span class="n">sigmas4</span><span class="p">)</span>
    <span class="n">pos4</span> <span class="o">=</span> <span class="n">get_pos</span><span class="p">(</span><span class="n">ma4</span><span class="p">)</span>
    <span class="n">neg4</span> <span class="o">=</span> <span class="n">get_neg</span><span class="p">(</span><span class="n">ma4</span><span class="p">)</span>

    <span class="n">ma8</span> <span class="o">=</span> <span class="n">moving_average</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
    <span class="n">sigmas8</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">ma8</span><span class="p">[:</span><span class="n">val_end</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">hi8</span> <span class="o">=</span> <span class="n">get_hi</span><span class="p">(</span><span class="n">ma8</span><span class="p">,</span> <span class="n">sigmas8</span><span class="p">)</span>
    <span class="n">lo8</span> <span class="o">=</span> <span class="n">get_lo</span><span class="p">(</span><span class="n">ma8</span><span class="p">,</span> <span class="n">sigmas8</span><span class="p">)</span>
    <span class="n">pos8</span> <span class="o">=</span> <span class="n">get_pos</span><span class="p">(</span><span class="n">ma8</span><span class="p">)</span>
    <span class="n">neg8</span> <span class="o">=</span> <span class="n">get_neg</span><span class="p">(</span><span class="n">ma8</span><span class="p">)</span>

    <span class="n">ma16</span> <span class="o">=</span> <span class="n">moving_average</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
    <span class="n">sigmas16</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">ma16</span><span class="p">[:</span><span class="n">val_end</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">hi16</span> <span class="o">=</span> <span class="n">get_hi</span><span class="p">(</span><span class="n">ma16</span><span class="p">,</span> <span class="n">sigmas16</span><span class="p">)</span>
    <span class="n">lo16</span> <span class="o">=</span> <span class="n">get_lo</span><span class="p">(</span><span class="n">ma16</span><span class="p">,</span> <span class="n">sigmas16</span><span class="p">)</span>
    <span class="n">pos16</span> <span class="o">=</span> <span class="n">get_pos</span><span class="p">(</span><span class="n">ma16</span><span class="p">)</span>
    <span class="n">neg16</span> <span class="o">=</span> <span class="n">get_neg</span><span class="p">(</span><span class="n">ma16</span><span class="p">)</span>

    <span class="n">ma32</span> <span class="o">=</span> <span class="n">moving_average</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
    <span class="n">sigmas32</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">ma32</span><span class="p">[:</span><span class="n">val_end</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">hi32</span> <span class="o">=</span> <span class="n">get_hi</span><span class="p">(</span><span class="n">ma32</span><span class="p">,</span> <span class="n">sigmas32</span><span class="p">)</span>
    <span class="n">lo32</span> <span class="o">=</span> <span class="n">get_lo</span><span class="p">(</span><span class="n">ma32</span><span class="p">,</span> <span class="n">sigmas32</span><span class="p">)</span>
    <span class="n">pos32</span> <span class="o">=</span> <span class="n">get_pos</span><span class="p">(</span><span class="n">ma32</span><span class="p">)</span>
    <span class="n">neg32</span> <span class="o">=</span> <span class="n">get_neg</span><span class="p">(</span><span class="n">ma32</span><span class="p">)</span>


    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">32</span><span class="p">:</span>
        <span class="n">features</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">hi</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">neg</span><span class="p">,</span> <span class="n">ma2</span><span class="p">,</span> <span class="n">ma4</span><span class="p">,</span> <span class="n">ma8</span><span class="p">,</span> <span class="n">ma16</span><span class="p">,</span> <span class="n">ma32</span><span class="p">,</span> <span class="n">hi2</span><span class="p">,</span> <span class="n">hi4</span><span class="p">,</span> <span class="n">hi8</span><span class="p">,</span> <span class="n">hi16</span><span class="p">,</span> <span class="n">hi32</span><span class="p">,</span> <span class="n">lo2</span><span class="p">,</span> <span class="n">lo4</span><span class="p">,</span> <span class="n">lo8</span><span class="p">,</span> <span class="n">lo16</span><span class="p">,</span> <span class="n">lo32</span><span class="p">,</span>\
            <span class="n">pos2</span><span class="p">,</span> <span class="n">pos4</span><span class="p">,</span> <span class="n">pos8</span><span class="p">,</span> <span class="n">pos16</span><span class="p">,</span> <span class="n">pos32</span><span class="p">,</span> <span class="n">neg2</span><span class="p">,</span> <span class="n">neg4</span><span class="p">,</span> <span class="n">neg8</span><span class="p">,</span> <span class="n">neg16</span><span class="p">,</span> <span class="n">neg32</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">n</span><span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
        <span class="n">features</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">hi</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">neg</span><span class="p">,</span> <span class="n">ma2</span><span class="p">,</span> <span class="n">ma4</span><span class="p">,</span> <span class="n">ma8</span><span class="p">,</span> <span class="n">hi2</span><span class="p">,</span> <span class="n">hi4</span><span class="p">,</span> <span class="n">hi8</span><span class="p">,</span> <span class="n">lo2</span><span class="p">,</span> <span class="n">lo4</span><span class="p">,</span> <span class="n">lo8</span><span class="p">,</span>\
            <span class="n">pos2</span><span class="p">,</span> <span class="n">pos4</span><span class="p">,</span> <span class="n">pos8</span><span class="p">,</span> <span class="n">neg2</span><span class="p">,</span> <span class="n">neg4</span><span class="p">,</span> <span class="n">neg8</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">n</span><span class="o">==</span> <span class="mi">16</span><span class="p">:</span>
        <span class="n">features</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">hi</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">neg</span><span class="p">,</span> <span class="n">ma2</span><span class="p">,</span> <span class="n">ma4</span><span class="p">,</span> <span class="n">ma8</span><span class="p">,</span> <span class="n">ma16</span><span class="p">,</span> <span class="n">hi2</span><span class="p">,</span> <span class="n">hi4</span><span class="p">,</span> <span class="n">hi8</span><span class="p">,</span> <span class="n">hi16</span><span class="p">,</span> <span class="n">lo2</span><span class="p">,</span> <span class="n">lo4</span><span class="p">,</span> <span class="n">lo8</span><span class="p">,</span> <span class="n">lo16</span><span class="p">,</span>\
            <span class="n">pos2</span><span class="p">,</span> <span class="n">pos4</span><span class="p">,</span> <span class="n">pos8</span><span class="p">,</span> <span class="n">pos16</span><span class="p">,</span> <span class="n">neg2</span><span class="p">,</span> <span class="n">neg4</span><span class="p">,</span> <span class="n">neg8</span><span class="p">,</span> <span class="n">neg16</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">n</span><span class="o">==</span><span class="mi">4</span><span class="p">:</span>
        <span class="n">features</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">hi</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">neg</span><span class="p">,</span> <span class="n">ma2</span><span class="p">,</span> <span class="n">ma4</span><span class="p">,</span> <span class="n">hi2</span><span class="p">,</span> <span class="n">hi4</span><span class="p">,</span> <span class="n">lo2</span><span class="p">,</span> <span class="n">lo4</span><span class="p">,</span>\
            <span class="n">pos2</span><span class="p">,</span> <span class="n">pos4</span><span class="p">,</span> <span class="n">neg2</span><span class="p">,</span> <span class="n">neg4</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">n</span><span class="o">==</span><span class="s2">&quot;ma2&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ma2</span>


    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">features</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">R</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">features</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])])</span></div>

<div class="viewcode-block" id="get_R"><a class="viewcode-back" href="../../autoapi/covariance/utils/index.html#covariance.utils.get_R">[docs]</a><span class="k">def</span> <span class="nf">get_R</span><span class="p">(</span><span class="n">R_whitenened</span><span class="p">,</span> <span class="n">Lt_invs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    param R_whitenened: numpy array of shape (T, n, 1) where T is the number of time steps and n is the number of assets</span>
<span class="sd">        these are the realized returns over the T days</span>
<span class="sd">    param Lt_invs: numpy array of shape (T, n, n) where T is the number of time steps and n is the number of assets</span>
<span class="sd">        these are the inverse of the whitening matrices</span>
<span class="sd">    </span>
<span class="sd">    returns: numpy array of shape (T, n) where T is the number of time steps and n is the number of assets</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">R_whitenened</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">R_whitenened</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">R</span> <span class="o">=</span> <span class="p">(</span><span class="n">Lt_invs</span> <span class="o">@</span> <span class="n">R_whitenened</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">R</span></div>


<div class="viewcode-block" id="get_V_hats"><a class="viewcode-back" href="../../autoapi/covariance/utils/index.html#covariance.utils.get_V_hats">[docs]</a><span class="k">def</span> <span class="nf">get_V_hats</span><span class="p">(</span><span class="n">vols</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    param vols: numpy array of shape (T, n) where T is the number of time steps and n is the number of assets</span>
<span class="sd">        these are the predicted volatilities over the T days</span>

<span class="sd">    returns: numpy array of shape (T, n, n) where T is the number of time steps and n is the number of assets</span>
<span class="sd">        these are the predicted diagonal volatility matrices over the T days</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">vols</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">vols</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">V_hats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">T</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
        <span class="n">V_hats</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">vols</span><span class="p">[</span><span class="n">t</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">V_hats</span></div>

<div class="viewcode-block" id="cp_get_log_likelihood"><a class="viewcode-back" href="../../autoapi/covariance/utils/index.html#covariance.utils.cp_get_log_likelihood">[docs]</a><span class="k">def</span> <span class="nf">cp_get_log_likelihood</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">Theta</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    param R: array of shape (n,1) where n is the number of assets</span>
<span class="sd">    param Theta: precision matrix of shape (n,n) where n is the number of assets</span>

<span class="sd">    returns: log likelihood of R given Theta</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">cp</span><span class="o">.</span><span class="n">log_det</span><span class="p">(</span><span class="n">Theta</span><span class="p">)</span> <span class="o">-</span> <span class="n">cp</span><span class="o">.</span><span class="n">quad_form</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">Theta</span><span class="p">)</span> </div>


<div class="viewcode-block" id="max_log_likelihood_const_L"><a class="viewcode-back" href="../../autoapi/covariance/utils/index.html#covariance.utils.max_log_likelihood_const_L">[docs]</a><span class="k">def</span> <span class="nf">max_log_likelihood_const_L</span><span class="p">(</span><span class="n">prob</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">Lt_params</span><span class="p">,</span> <span class="n">Lt_times_R_vec_params</span><span class="p">,</span> <span class="n">Lt_hat</span><span class="p">,</span> <span class="n">Lt_times_R_vec</span><span class="p">,</span> <span class="n">prob_num</span><span class="p">,</span> <span class="n">ignore_dpp</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    param whiteners: array of shape (M, n, n) where M is the number of predictor candidates, and n is the number of assets</span>
<span class="sd">        whiteners[i] = Li^T, where Li*Li^T=Sigma_i, the precission matrix of the i-th predictor</span>
<span class="sd">    param R: numpy array of shape (T, n, 1) where T is the number of time steps and n is the number of assets</span>
<span class="sd">        these are the realized returns over the T days</span>

<span class="sd">    returns the weights that maximize the log likelihood of the data given M constant whiteners </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span> <span class="c1"># TODO: just a quick fix for with_pooling=False case</span>
        <span class="k">if</span> <span class="n">prob_num</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="n">prob_num</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prob_num</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">prob_num</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.0%</span><span class="si">}</span><span class="s2"> done...&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="n">n_predictors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Lt_params</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_predictors</span><span class="p">):</span>
        <span class="n">Lt_params</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">Lt_hat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">Lt_times_R_vec_params</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">Lt_times_R_vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    
    <span class="k">try</span><span class="p">:</span>
        <span class="n">prob</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">solver</span><span class="o">=</span><span class="s2">&quot;MOSEK&quot;</span><span class="p">,</span> <span class="n">ignore_dpp</span><span class="o">=</span><span class="n">ignore_dpp</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Solver failed...&quot;</span><span class="p">)</span>
        <span class="n">prob</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">solver</span><span class="o">=</span><span class="s2">&quot;MOSEK&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="k">assert</span> <span class="n">prob</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="s2">&quot;optimal&quot;</span>

    <span class="k">return</span> <span class="n">w</span><span class="o">.</span><span class="n">value</span></div>


<div class="viewcode-block" id="max_log_likelihood_varying_L"><a class="viewcode-back" href="../../autoapi/covariance/utils/index.html#covariance.utils.max_log_likelihood_varying_L">[docs]</a><span class="k">def</span> <span class="nf">max_log_likelihood_varying_L</span><span class="p">(</span><span class="n">prob</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">Lt_params</span><span class="p">,</span> <span class="n">Lt_times_R_vec_params</span><span class="p">,</span> <span class="n">Lt_hat</span><span class="p">,</span> <span class="n">Lt_times_R_vec</span><span class="p">,</span> <span class="n">prob_num</span><span class="p">,</span> <span class="n">ignore_dpp</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    param whiteners: array of shape (M, n, n) where M is the number of predictor candidates, and n is the number of assets</span>
<span class="sd">        whiteners[i] = Li^T, where Li*Li^T=Sigma_i, the precission matrix of the i-th predictor</span>
<span class="sd">    param R: numpy array of shape (T, n, 1) where T is the number of time steps and n is the number of assets</span>
<span class="sd">        these are the realized returns over the T days</span>

<span class="sd">    returns the weights that maximize the log likelihood of the data given M constant whiteners </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span> <span class="c1"># TODO: just a quick fix for with_pooling=False case</span>
        <span class="k">if</span> <span class="n">prob_num</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="n">prob_num</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prob_num</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">prob_num</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.0%</span><span class="si">}</span><span class="s2"> done...&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="n">n_predictors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Lt_params</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_predictors</span><span class="p">):</span>
        <span class="n">Lt_params</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">Lt_hat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">Lt_times_R_vec_params</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">Lt_times_R_vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    
    <span class="k">try</span><span class="p">:</span>
        <span class="n">prob</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">solver</span><span class="o">=</span><span class="s2">&quot;MOSEK&quot;</span><span class="p">,</span> <span class="n">ignore_dpp</span><span class="o">=</span><span class="n">ignore_dpp</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Solver failed...&quot;</span><span class="p">)</span>
        <span class="n">prob</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">solver</span><span class="o">=</span><span class="s2">&quot;MOSEK&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="k">assert</span> <span class="n">prob</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="s2">&quot;optimal&quot;</span>

    <span class="k">return</span> <span class="n">w</span><span class="o">.</span><span class="n">value</span></div>






    

<div class="viewcode-block" id="max_log_likelihood"><a class="viewcode-back" href="../../autoapi/covariance/utils/index.html#covariance.utils.max_log_likelihood">[docs]</a><span class="k">def</span> <span class="nf">max_log_likelihood</span><span class="p">(</span><span class="n">prob</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">prec_params</span><span class="p">,</span> <span class="n">prec_at_cov_params</span><span class="p">,</span> <span class="n">precisions</span><span class="p">,</span> <span class="n">prec_at_covs</span><span class="p">,</span> <span class="n">prob_num</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    param precisions: numpy array of shape (T, M, n, n) where T is the number of time steps, M is the number of predictor candidates, and n is the number of assets</span>
<span class="sd">    param R: numpy array of shape (T, n, 1) where T is the number of time steps and n is the number of assets</span>
<span class="sd">        these are the realized returns over the T days</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">prob_num</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="n">prob_num</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prob_num</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">prob_num</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.0%</span><span class="si">}</span><span class="s2"> done...&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>

    <span class="n">n_predictors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">precisions</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">T</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">precisions</span><span class="p">)</span>

    <span class="c1"># Solve problem once for speedup later</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_predictors</span><span class="p">):</span>
            <span class="n">prec_params</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">precisions</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
            <span class="n">prec_at_cov_params</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">prec_at_covs</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Solver failed...&quot;</span><span class="p">)</span>
        <span class="n">prob</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">solver</span><span class="o">=</span><span class="s2">&quot;MOSEK&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ignore_dpp</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">w_temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_predictors</span><span class="p">)</span>
        <span class="n">w_temp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">w_temp</span>
    <span class="k">return</span> <span class="n">w</span><span class="o">.</span><span class="n">value</span></div>


<div class="viewcode-block" id="max_log_likelihood_const_theta"><a class="viewcode-back" href="../../autoapi/covariance/utils/index.html#covariance.utils.max_log_likelihood_const_theta">[docs]</a><span class="k">def</span> <span class="nf">max_log_likelihood_const_theta</span><span class="p">(</span><span class="n">prob</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">prec_params</span><span class="p">,</span> <span class="n">prec_at_cov_params</span><span class="p">,</span> <span class="n">precisions</span><span class="p">,</span> <span class="n">prec_at_covs</span><span class="p">,</span> <span class="n">prob_num</span><span class="p">):</span> 
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    param precisions: array of shape (M, n, n) M is the number of predictor candidates, and n is the number of assets</span>
<span class="sd">    param R: numpy array of shape (T, n) where T is the number of time steps and n is the number of assets</span>
<span class="sd">        these are the realized returns over the T days</span>

<span class="sd">    returns the weights that maximize the log likelihood of the data given M constant precision matrices</span>
<span class="sd">        i.e., in comparison to max_log_likelihood, this function assumes that the precision matrices are constant over time t=1,2,...,T</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">prob_num</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="n">prob_num</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prob_num</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">prob_num</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.0%</span><span class="si">}</span><span class="s2"> done...&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>

    <span class="n">n_predictors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">precisions</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_predictors</span><span class="p">):</span>
        <span class="n">Theta_temp</span> <span class="o">=</span> <span class="n">precisions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">prec_params</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">Theta_temp</span>
        <span class="n">prec_at_cov_params</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">prec_at_covs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="n">prob</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">solver</span><span class="o">=</span><span class="s2">&quot;MOSEK&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">w</span><span class="o">.</span><span class="n">value</span></div>

<div class="viewcode-block" id="get_overtriangular"><a class="viewcode-back" href="../../autoapi/covariance/utils/index.html#covariance.utils.get_overtriangular">[docs]</a><span class="k">def</span> <span class="nf">get_overtriangular</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    returns the upper triangular part of a matrix M (including the diagonal)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">M</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">triu_indices</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">)]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="get_overtriangular_stack"><a class="viewcode-back" href="../../autoapi/covariance/utils/index.html#covariance.utils.get_overtriangular_stack">[docs]</a><span class="k">def</span> <span class="nf">get_overtriangular_stack</span><span class="p">(</span><span class="n">Ms</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    returns the upper triangular part of a list of matrices Ms (including the diagonal)\</span>
<span class="sd">        upper diagonals are returned as rows in a matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">get_overtriangular</span><span class="p">(</span><span class="n">M</span><span class="p">)</span> <span class="k">for</span> <span class="n">M</span> <span class="ow">in</span> <span class="n">Ms</span><span class="p">])</span></div>

<div class="viewcode-block" id="get_vectorform"><a class="viewcode-back" href="../../autoapi/covariance/utils/index.html#covariance.utils.get_vectorform">[docs]</a><span class="k">def</span> <span class="nf">get_vectorform</span><span class="p">(</span><span class="n">R</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    returns the form of R that is used to compute L^T * R elementwise</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">R_new</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">R_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">R_new</span><span class="p">,</span> <span class="n">R</span><span class="p">[:,</span><span class="n">i</span><span class="p">:]))</span>
    <span class="k">return</span> <span class="n">R_new</span></div>

<div class="viewcode-block" id="max_log_likelihood_varying_L2"><a class="viewcode-back" href="../../autoapi/covariance/utils/index.html#covariance.utils.max_log_likelihood_varying_L2">[docs]</a><span class="k">def</span> <span class="nf">max_log_likelihood_varying_L2</span><span class="p">(</span><span class="n">prob</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">P_param</span><span class="p">,</span> <span class="n">onest_A_param</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">onest_A</span><span class="p">,</span> <span class="n">prob_num</span><span class="p">,</span> <span class="n">ignore_dpp</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    param whiteners: array of shape (M, n, n) where M is the number of predictor candidates, and n is the number of assets</span>
<span class="sd">        whiteners[i] = Li^T, where Li*Li^T=Sigma_i, the precission matrix of the i-th predictor</span>
<span class="sd">    param R: numpy array of shape (T, n, 1) where T is the number of time steps and n is the number of assets</span>
<span class="sd">        these are the realized returns over the T days</span>

<span class="sd">    returns the weights that maximize the log likelihood of the data given M constant whiteners </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">P_param</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">P</span> 
    <span class="n">onest_A_param</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">onest_A</span> 

    <span class="k">try</span><span class="p">:</span> <span class="c1"># TODO: just a quick fix for with_pooling=False case</span>
        <span class="k">if</span> <span class="n">prob_num</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="n">prob_num</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prob_num</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">prob_num</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.0%</span><span class="si">}</span><span class="s2"> done...&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">prob</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">solver</span><span class="o">=</span><span class="s2">&quot;ECOS&quot;</span><span class="p">,</span> <span class="n">ignore_dpp</span><span class="o">=</span><span class="n">ignore_dpp</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Solver failed...&quot;</span><span class="p">)</span>
        <span class="n">prob</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">solver</span><span class="o">=</span><span class="s2">&quot;ECOS&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="k">assert</span> <span class="n">prob</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="s2">&quot;optimal&quot;</span>

    <span class="k">return</span> <span class="n">w</span><span class="o">.</span><span class="n">value</span></div>

<div class="viewcode-block" id="get_opt_weights_new"><a class="viewcode-back" href="../../autoapi/covariance/utils/index.html#covariance.utils.get_opt_weights_new">[docs]</a><span class="k">def</span> <span class="nf">get_opt_weights_new</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">likelihood_window</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">w_init</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">const_theta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">const_L</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">turnover_cons</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    param model: Covariance predictor model</span>
<span class="sd">    param likelihood_window: number of past days to use to compute the log likelihood</span>
<span class="sd">    param w_init: initial weights to use for the convex optimization problem</span>
<span class="sd">    param const_theta: whether the precision matrices are constant over time or not</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># print(&quot;Turnover limit: &quot;,turnover_cons)</span>
    <span class="n">Theta_hats_for_all_t</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">prec_at_covs_for_all_t</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">R_for_all_t</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">A_for_all_t</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">P_for_all_t</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">Lt_hats_for_all_t</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">R_vec_for_all_t</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">Lt_times_R_vec_for_all_t</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">n_predictors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">predictors</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">n</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">T</span>

    <span class="c1"># Parametrize problem for weighted average of precision matrices</span>
    <span class="k">if</span> <span class="n">const_L</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">const_theta</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">const_theta</span> <span class="o">==</span> <span class="s2">&quot;on&quot;</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="n">n_predictors</span><span class="p">)</span>
            <span class="n">precision_params</span> <span class="o">=</span> <span class="p">[</span><span class="n">cp</span><span class="o">.</span><span class="n">Parameter</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">PSD</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_predictors</span><span class="p">)]</span>
            <span class="n">prec_at_cov_params</span> <span class="o">=</span> <span class="p">[</span><span class="n">cp</span><span class="o">.</span><span class="n">Parameter</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_predictors</span><span class="p">)]</span>

            <span class="n">Theta_hat</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">precision_params</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_predictors</span><span class="p">)])</span>
            <span class="n">trace_arg</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">prec_at_cov_params</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_predictors</span><span class="p">)])</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">Maximize</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">log_det</span><span class="p">(</span><span class="n">Theta_hat</span><span class="p">)</span> <span class="o">-</span> <span class="n">cp</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">trace_arg</span><span class="p">))</span>

        <span class="k">elif</span> <span class="n">const_theta</span> <span class="o">==</span> <span class="s2">&quot;off&quot;</span><span class="p">:</span>

            <span class="n">w</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="n">n_predictors</span><span class="p">)</span>
            <span class="n">precision_params</span> <span class="o">=</span> <span class="p">[[</span><span class="n">cp</span><span class="o">.</span><span class="n">Parameter</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">PSD</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_predictors</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">likelihood_window</span><span class="p">)]</span>
            <span class="n">prec_at_cov_params</span> <span class="o">=</span> <span class="p">[[</span><span class="n">cp</span><span class="o">.</span><span class="n">Parameter</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_predictors</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">likelihood_window</span><span class="p">)]</span>

            <span class="n">Theta_hat</span> <span class="o">=</span> <span class="p">[</span><span class="n">cp</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">precision_params</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_predictors</span><span class="p">)])</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">likelihood_window</span><span class="p">)]</span>
            <span class="n">trace_arg</span> <span class="o">=</span> <span class="p">[</span><span class="n">cp</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">prec_at_cov_params</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_predictors</span><span class="p">)])</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">likelihood_window</span><span class="p">)]</span>

            <span class="n">log_likelihood</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">cp</span><span class="o">.</span><span class="n">log_det</span><span class="p">(</span><span class="n">Theta_hat</span><span class="p">[</span><span class="n">t</span><span class="p">])</span> <span class="o">-</span> <span class="n">cp</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">trace_arg</span><span class="p">[</span><span class="n">t</span><span class="p">])</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">likelihood_window</span><span class="p">)])</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">Maximize</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">log_likelihood</span><span class="p">))</span>

        <span class="n">cons</span> <span class="o">=</span> <span class="p">[</span><span class="n">cp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">w</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">prob</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">Problem</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">cons</span><span class="p">)</span>
        <span class="c1"># print(prob.is_dcp(dpp=True))</span>

        <span class="c1"># prob = cp.Problem(obj, [cp.sum(w) == 1, w &gt;= 0])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">const_theta</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="k">assert</span> <span class="n">const_L</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">const_L</span> <span class="o">==</span> <span class="s2">&quot;on&quot;</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="n">n_predictors</span><span class="p">)</span>

            <span class="c1"># Each Lt has shape number of overtriangular elements in L^T</span>
            <span class="n">n_overtriangular</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">Lt_params</span> <span class="o">=</span> <span class="p">[</span><span class="n">cp</span><span class="o">.</span><span class="n">Parameter</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">n_overtriangular</span><span class="p">))</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_predictors</span><span class="p">)]</span>
            <span class="n">Lt_hat</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">Lt_params</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_predictors</span><span class="p">)])</span>

            <span class="c1"># Compute the norm part of the objective</span>
            <span class="n">Lt_times_R_vec_params</span> <span class="o">=</span> <span class="p">[</span><span class="n">cp</span><span class="o">.</span><span class="n">Parameter</span><span class="p">((</span><span class="n">likelihood_window</span><span class="p">,</span> <span class="n">n_overtriangular</span><span class="p">))</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_predictors</span><span class="p">)]</span> <span class="c1"># Lt_m*R_t elementwise for flattened Lt overtri.</span>
            <span class="n">norm_arg</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">Lt_times_R_vec_params</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_predictors</span><span class="p">)])</span>
            <span class="n">sums</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">cp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">norm_arg</span><span class="p">[:,</span><span class="n">i</span><span class="o">*</span><span class="n">n</span><span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">):(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">n</span><span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)])</span> <span class="c1"># TODO: I think this is right...</span>


            <span class="n">diag_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">n</span><span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

        <span class="k">elif</span> <span class="n">const_L</span> <span class="o">==</span> <span class="s2">&quot;off&quot;</span><span class="p">:</span>
            <span class="c1">########### NEW APPROACH</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="n">n_predictors</span><span class="p">)</span>
            <span class="n">P_param</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">Parameter</span><span class="p">((</span><span class="n">n_predictors</span><span class="p">,</span><span class="n">n_predictors</span><span class="p">),</span> <span class="n">PSD</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">A_param</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">Parameter</span><span class="p">((</span><span class="n">n</span><span class="o">*</span><span class="n">likelihood_window</span><span class="p">,</span><span class="n">n_predictors</span><span class="p">))</span>

            <span class="n">obj</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">Maximize</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">A_param</span><span class="nd">@w</span><span class="p">))</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">quad_form</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">P_param</span><span class="p">))</span>



        <span class="n">cons</span> <span class="o">=</span> <span class="p">[</span><span class="n">cp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">w</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">turnover_cons</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">w_old</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="n">n_predictors</span><span class="p">)</span>
            <span class="c1"># w_old.value = np.zeros(n_predictors); w_old.value[-1] = 1 # initialize to last predictor</span>
            <span class="n">w_old</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_predictors</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_predictors</span>
            <span class="n">cons</span> <span class="o">+=</span> <span class="p">[</span><span class="n">cp</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">w</span><span class="o">-</span><span class="n">w_old</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">turnover_cons</span><span class="p">]</span> 
        <span class="k">else</span><span class="p">:</span>
            <span class="n">w_old</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">prob</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">Problem</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">cons</span><span class="p">)</span>


    <span class="c1"># Define parameter values for each time step</span>
    <span class="c1"># TODO: I changed from t-1 to t (this should still be causal)</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">likelihood_window</span><span class="p">,</span> <span class="n">T</span><span class="p">):</span>
        <span class="n">R_t</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">t</span><span class="o">-</span><span class="p">(</span><span class="n">likelihood_window</span><span class="p">):</span><span class="n">t</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">R_for_all_t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">R_t</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">const_theta</span> <span class="o">==</span> <span class="s2">&quot;on&quot;</span><span class="p">:</span>
            <span class="n">Theta_hats_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">*</span><span class="n">predictor</span><span class="o">.</span><span class="n">Theta_hats</span><span class="o">.</span><span class="n">values</span><span class="p">()][</span><span class="n">t</span><span class="p">]</span> <span class="k">for</span> <span class="n">predictor</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">predictors</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span> <span class="c1"># get CURRENT day&#39;s precision matrices (at time t!)</span>
            <span class="n">sample_covs_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">R_t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="nd">@R_t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">likelihood_window</span><span class="p">))</span> <span class="o">/</span> <span class="n">likelihood_window</span> <span class="c1"># Don&#39;t include t!</span>
            <span class="n">prec_at_covs_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Theta_hats_t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">@</span> <span class="n">sample_covs_t</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_predictors</span><span class="p">)])</span>
        <span class="k">elif</span> <span class="n">const_theta</span> <span class="o">==</span> <span class="s2">&quot;off&quot;</span><span class="p">:</span>
            <span class="n">set_of_Theta_hats_t</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">set_of_prec_at_covs_t</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">predictor</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">predictors</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="c1"># Precision matrices</span>
                <span class="n">Theta_hats_temp</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="n">predictor</span><span class="o">.</span><span class="n">Theta_hats</span><span class="o">.</span><span class="n">values</span><span class="p">()][</span><span class="n">t</span><span class="o">-</span><span class="p">(</span><span class="n">likelihood_window</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span><span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">set_of_Theta_hats_t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Theta_hats_temp</span><span class="p">)</span>

                <span class="c1"># (Precision @ sample covariance matrices) (just one sample per time step...)</span>
                <span class="n">prec_at_covs_temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Theta_hats_temp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">@</span> <span class="n">R_t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="nd">@R_t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">likelihood_window</span><span class="p">)])</span>
                <span class="n">set_of_prec_at_covs_t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prec_at_covs_temp</span><span class="p">)</span>
            <span class="n">Theta_hats_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">set_of_Theta_hats_t</span><span class="p">),</span> <span class="p">(</span><span class="n">likelihood_window</span><span class="p">,</span> <span class="n">n_predictors</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
            <span class="n">prec_at_covs_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">set_of_prec_at_covs_t</span><span class="p">),</span> <span class="p">(</span><span class="n">likelihood_window</span><span class="p">,</span> <span class="n">n_predictors</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">const_L</span> <span class="o">==</span> <span class="s2">&quot;on&quot;</span><span class="p">:</span>
            <span class="n">Lt_hats_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">get_overtriangular</span><span class="p">([</span><span class="o">*</span><span class="n">predictor</span><span class="o">.</span><span class="n">Lt_hats</span><span class="o">.</span><span class="n">values</span><span class="p">()][</span><span class="n">t</span><span class="p">])</span> <span class="k">for</span> <span class="n">predictor</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">predictors</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span> <span class="c1"># get CURRENT day&#39;s Cholesky matrices (at time t!)</span>
            <span class="n">R_vec_t</span> <span class="o">=</span> <span class="n">get_vectorform</span><span class="p">(</span><span class="n">R_t</span><span class="p">)</span>
            <span class="n">Lt_times_R_vec_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">R_vec_t</span> <span class="o">*</span> <span class="n">Lt_hats_t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_predictors</span><span class="p">)])</span>

        <span class="k">elif</span> <span class="n">const_L</span> <span class="o">==</span> <span class="s2">&quot;off&quot;</span><span class="p">:</span>
            <span class="c1"># TODO: I changed from t-1 to t (this should still be causal)</span>
            <span class="n">R_t</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">t</span><span class="o">-</span><span class="p">(</span><span class="n">likelihood_window</span><span class="p">):</span><span class="n">t</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">values</span>

            <span class="n">Lt_hats_t</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">R_vec_t</span> <span class="o">=</span> <span class="n">get_vectorform</span><span class="p">(</span><span class="n">R_t</span><span class="p">)</span>

            <span class="n">A_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="o">*</span><span class="n">likelihood_window</span><span class="p">,</span> <span class="n">n_predictors</span><span class="p">))</span>
            <span class="n">all_B_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">likelihood_window</span><span class="p">,</span> <span class="n">n_predictors</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">predictor</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">predictors</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="c1"># Cholesky matrices</span>
                <span class="n">Lt_hats_temp</span> <span class="o">=</span> <span class="n">get_overtriangular_stack</span><span class="p">([</span><span class="o">*</span><span class="n">predictor</span><span class="o">.</span><span class="n">Lt_hats</span><span class="o">.</span><span class="n">values</span><span class="p">()][</span><span class="n">t</span><span class="o">-</span><span class="p">(</span><span class="n">likelihood_window</span><span class="p">):</span><span class="n">t</span><span class="p">])</span>
                <span class="n">Lt_hats_t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Lt_hats_temp</span><span class="p">)</span>

                <span class="c1">### NEW APPROACH</span>
                <span class="c1"># Compute A_t and P_t</span>
                <span class="n">Lt_hats_temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">*</span><span class="n">predictor</span><span class="o">.</span><span class="n">Lt_hats</span><span class="o">.</span><span class="n">values</span><span class="p">()][</span><span class="n">t</span><span class="o">-</span><span class="p">(</span><span class="n">likelihood_window</span><span class="p">):</span><span class="n">t</span><span class="p">])</span>

                <span class="n">A_t</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">Lt_hats_temp</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span>\
                     <span class="nb">range</span><span class="p">(</span><span class="n">likelihood_window</span><span class="p">)])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,)</span>


                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">likelihood_window</span><span class="p">):</span>
                    <span class="n">r_j</span> <span class="o">=</span> <span class="n">R_t</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">Lt_j</span> <span class="o">=</span> <span class="n">Lt_hats_temp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">all_B_t</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">r_j</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">Lt_j</span><span class="o">.</span><span class="n">T</span>
                
            <span class="n">P_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_predictors</span><span class="p">,</span> <span class="n">n_predictors</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">likelihood_window</span><span class="p">):</span>
                <span class="n">B_j</span> <span class="o">=</span> <span class="n">all_B_t</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">P_t</span> <span class="o">+=</span> <span class="n">B_j</span> <span class="o">@</span> <span class="n">B_j</span><span class="o">.</span><span class="n">T</span>
            <span class="c1"># ones = np.ones((n*likelihood_window,1))</span>
            <span class="c1"># onest_A_t = ones.T @ A_t</span>


            <span class="n">Lt_times_R_vec_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">R_vec_t</span> <span class="o">*</span> <span class="n">Lt_hats_t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_predictors</span><span class="p">)])</span>
        

        <span class="k">if</span> <span class="n">const_L</span> <span class="o">==</span> <span class="s2">&quot;on&quot;</span> <span class="ow">or</span> <span class="n">const_L</span> <span class="o">==</span> <span class="s2">&quot;off&quot;</span><span class="p">:</span>
            <span class="n">Lt_hats_for_all_t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Lt_hats_t</span><span class="p">)</span>
            <span class="n">R_vec_for_all_t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">R_vec_t</span><span class="p">)</span>
            <span class="n">Lt_times_R_vec_for_all_t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Lt_times_R_vec_t</span><span class="p">)</span>

            <span class="n">P_for_all_t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">P_t</span><span class="p">)</span>
            <span class="n">A_for_all_t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A_t</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">Theta_hats_for_all_t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Theta_hats_t</span><span class="p">)</span>
            <span class="n">prec_at_covs_for_all_t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prec_at_covs_t</span><span class="p">)</span>
    
    <span class="c1"># Solve problem for each t in parallel</span>
    <span class="k">if</span> <span class="n">const_L</span><span class="o">==</span><span class="s2">&quot;on&quot;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Solving convex problem for constant L...&quot;</span><span class="p">)</span>
        <span class="n">opt_model</span> <span class="o">=</span> <span class="n">max_log_likelihood_const_L</span>
    <span class="k">elif</span> <span class="n">const_L</span><span class="o">==</span><span class="s2">&quot;off&quot;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Solving convex problem for time-varying L...&quot;</span><span class="p">)</span>
        <span class="n">opt_model</span> <span class="o">=</span> <span class="n">max_log_likelihood_varying_L</span>
        <span class="n">opt_model</span> <span class="o">=</span> <span class="n">max_log_likelihood_varying_L2</span>

    <span class="k">elif</span> <span class="n">const_theta</span><span class="o">==</span><span class="s2">&quot;on&quot;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Solving convex problem for constant theta...&quot;</span><span class="p">)</span>
        <span class="n">opt_model</span> <span class="o">=</span> <span class="n">max_log_likelihood_const_theta</span>
    <span class="k">elif</span> <span class="n">const_theta</span><span class="o">==</span><span class="s2">&quot;off&quot;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Solving convex problem for time-varying theta...&quot;</span><span class="p">)</span>
        <span class="n">opt_model</span> <span class="o">=</span> <span class="n">max_log_likelihood</span>
    

    <span class="k">if</span> <span class="n">turnover_cons</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># No turnover constraint, so we can problems in parallel</span>
        <span class="n">with_pooling</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># TODO: FIX</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">with_pooling</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">with_pooling</span><span class="p">:</span>
        <span class="c1"># Solve in parallel</span>
        <span class="k">with</span> <span class="n">ProcessPoolExecutor</span><span class="p">()</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span> <span class="c1"># TODO: This can probably be removed... Using multiprocessing.Pool instead</span>
        <span class="c1"># Use tqdm to display a progress bar</span>
            <span class="k">if</span> <span class="n">const_L</span> <span class="o">==</span> <span class="s2">&quot;on&quot;</span> <span class="ow">or</span> <span class="n">const_L</span> <span class="o">==</span> <span class="s2">&quot;off&quot;</span><span class="p">:</span>
                <span class="c1"># ws = list(tqdm(executor.map(opt_model, Lt_hats_for_all_t, R_for_all_t), total=len(Lt_hats_for_all_t)))</span>
                <span class="c1"># Solve problem once for speedup later</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_predictors</span><span class="p">):</span>
                    <span class="n">Lt_params</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">Lt_hats_for_all_t</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">Lt_times_R_vec_params</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">Lt_times_R_vec_for_all_t</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="n">prob</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">ignore_dpp</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">ignore_dpp</span><span class="p">)</span>
                


                <span class="n">Lt_param_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">Lt_params</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">R_vec_for_all_t</span><span class="p">))]</span>
                <span class="n">Lt_times_R_vec_param_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">Lt_times_R_vec_params</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">R_vec_for_all_t</span><span class="p">))]</span>
                <span class="n">prob_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">prob</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">R_vec_for_all_t</span><span class="p">))]</span>
                <span class="n">w_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">w</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">R_vec_for_all_t</span><span class="p">))]</span>
                <span class="n">ignore_dpp_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">model</span><span class="o">.</span><span class="n">ignore_dpp</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">R_vec_for_all_t</span><span class="p">))]</span>

                <span class="c1"># Keep track on how many problems left to solve</span>
                <span class="n">prob_nums</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">R_for_all_t</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">R_for_all_t</span><span class="p">))]</span>

                <span class="c1"># Solve all problems in parallel</span>
                <span class="n">pool</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">Pool</span><span class="p">()</span>
                <span class="c1"># ws = pool.starmap(opt_model, zip(prob_list, w_list, Lt_param_list, Lt_times_R_vec_param_list, \</span>
                <span class="c1">#             Lt_hats_for_all_t, Lt_times_R_vec_for_all_t, prob_nums, ignore_dpp_list))</span>
                
                <span class="n">ws</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">opt_model</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">prob</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">P_param</span><span class="p">,</span> <span class="n">A_param</span><span class="p">,</span>\
                     <span class="n">P_for_all_t</span><span class="p">[</span><span class="n">t</span><span class="p">],</span> <span class="n">A_for_all_t</span><span class="p">[</span><span class="n">t</span><span class="p">],</span> <span class="n">t</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">ignore_dpp</span><span class="p">))</span>
                <span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>




            <span class="k">elif</span> <span class="n">const_theta</span> <span class="o">==</span> <span class="s2">&quot;on&quot;</span><span class="p">:</span>
                <span class="c1"># Solve problem once for speedup later</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_predictors</span><span class="p">):</span>
                    <span class="n">Theta_temp</span> <span class="o">=</span> <span class="n">Theta_hats_for_all_t</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">precision_params</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">Theta_temp</span>
                    <span class="n">prec_at_cov_params</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">prec_at_covs_for_all_t</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="n">prob</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>

                <span class="n">prec_param_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">precision_params</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">R_for_all_t</span><span class="p">))]</span>
                <span class="n">prec_at_cov_param_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">prec_at_cov_params</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">R_for_all_t</span><span class="p">))]</span>
                <span class="n">prob_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">prob</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">R_for_all_t</span><span class="p">))]</span>
                <span class="n">w_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">w</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">R_for_all_t</span><span class="p">))]</span>

                <span class="c1"># Keep track on how many problems left to solve</span>
                <span class="n">prob_nums</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">R_for_all_t</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">R_for_all_t</span><span class="p">))]</span>

                <span class="n">pool</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">Pool</span><span class="p">()</span>
                <span class="n">ws</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">opt_model</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">prob_list</span><span class="p">,</span> <span class="n">w_list</span><span class="p">,</span> <span class="n">prec_param_list</span><span class="p">,</span> <span class="n">prec_at_cov_param_list</span><span class="p">,</span> \
                            <span class="n">Theta_hats_for_all_t</span><span class="p">,</span> <span class="n">prec_at_covs_for_all_t</span><span class="p">,</span> <span class="n">prob_nums</span><span class="p">))</span>
                <span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">const_theta</span> <span class="o">==</span> <span class="s2">&quot;off&quot;</span><span class="p">:</span>
                <span class="c1"># Solve problem once for speedup later</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">likelihood_window</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_predictors</span><span class="p">):</span>
                        <span class="n">precision_params</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">Theta_hats_for_all_t</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">t</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                        <span class="n">prec_at_cov_params</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">prec_at_covs_for_all_t</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">t</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="n">prob</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">ignore_dpp</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="n">prec_param_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">precision_params</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">R_for_all_t</span><span class="p">))]</span>
                <span class="n">prec_at_cov_param_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">prec_at_cov_params</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">R_for_all_t</span><span class="p">))]</span>
                <span class="n">prob_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">prob</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">R_for_all_t</span><span class="p">))]</span>
                <span class="n">w_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">w</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">R_for_all_t</span><span class="p">))]</span>

                <span class="c1"># Keep track on how many problems left to solve</span>
                <span class="n">prob_nums</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">R_for_all_t</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">R_for_all_t</span><span class="p">))]</span>

                <span class="n">pool</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">Pool</span><span class="p">()</span>
                <span class="n">ws</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">opt_model</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">prob_list</span><span class="p">,</span> <span class="n">w_list</span><span class="p">,</span> <span class="n">prec_param_list</span><span class="p">,</span> <span class="n">prec_at_cov_param_list</span><span class="p">,</span> \
                            <span class="n">Theta_hats_for_all_t</span><span class="p">,</span> <span class="n">prec_at_covs_for_all_t</span><span class="p">,</span> <span class="n">prob_nums</span><span class="p">))</span>
                <span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Solve sequentially</span>
        <span class="n">ws</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">trange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Lt_hats_for_all_t</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">const_L</span> <span class="o">==</span> <span class="s2">&quot;off&quot;</span><span class="p">:</span>


                <span class="c1"># w_t = opt_model(prob, w, Lt_params, Lt_times_R_vec_params,</span>
                <span class="c1"># Lt_hats_for_all_t[t], Lt_times_R_vec_for_all_t[t], t,</span>
                <span class="c1"># model.ignore_dpp)</span>

                <span class="n">w_t</span> <span class="o">=</span> <span class="n">opt_model</span><span class="p">(</span><span class="n">prob</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">P_param</span><span class="p">,</span> <span class="n">A_param</span><span class="p">,</span>\
                     <span class="n">P_for_all_t</span><span class="p">[</span><span class="n">t</span><span class="p">],</span> <span class="n">A_for_all_t</span><span class="p">[</span><span class="n">t</span><span class="p">],</span> <span class="n">t</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">ignore_dpp</span><span class="p">)</span>


                <span class="n">ws</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w_t</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
                <span class="k">if</span> <span class="n">w_old</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">w_old</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">w_t</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="c1"># if const_L == &quot;on&quot; or const_L == &quot;off&quot;:</span>
            <span class="c1">#     w = opt_model(Lt_hats_for_all_t[t], R_for_all_t[t])</span>
            <span class="c1"># else:</span>
            <span class="c1">#     w = opt_model(Theta_hats_for_all_t[t], R_for_all_t[t])</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Finishing...&quot;</span><span class="p">)</span>

    <span class="c1"># TODO: I changed from likelihood_window+1 to likelihood_window</span>
    <span class="n">ws</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">ws</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">likelihood_window</span><span class="p">:])</span>
    <span class="k">return</span> <span class="n">ws</span></div>


<div class="viewcode-block" id="get_opt_weights_old"><a class="viewcode-back" href="../../autoapi/covariance/utils/index.html#covariance.utils.get_opt_weights_old">[docs]</a><span class="k">def</span> <span class="nf">get_opt_weights_old</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">prob</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">theta_params</span><span class="p">,</span> <span class="n">likelihood_window</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">w_init</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">const_theta</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Choose the weights to combine the inverse covariance matrices by solving the following convex problem:  what (constant) weights would have maximized the log likelihood on the last &#39;likelihood_window&#39; days? This is a convex problem, so we can solve it with cvxpy.</span>

<span class="sd">    param model: Covariance predictor model</span>
<span class="sd">    param t: time step (pandas date-time object) for which we want to compute the optimal weights</span>
<span class="sd">    param prob: cvxpy problem object</span>
<span class="sd">    param w: cvxpy variable object</span>
<span class="sd">    param theta_params: array of cvxpy parameters for the precision matrix</span>
<span class="sd">    param likelihood_window: number of past days to use to compute the log likelihood</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">n</span>
    <span class="n">n_predictors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">predictors</span><span class="p">)</span>

    <span class="c1"># t = np.where(model.R.index == t)[0][0] # get the index of the time step t (t is originally a pandas date-time object)</span>
    <span class="n">R_temp</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">t</span><span class="o">-</span><span class="p">(</span><span class="n">likelihood_window</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span><span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">values</span> <span class="c1"># Don&#39;t include t; avoid look-ahead bias </span>
    
    <span class="n">Theta_hats_t</span> <span class="o">=</span> <span class="p">[[</span><span class="o">*</span><span class="n">predictor</span><span class="o">.</span><span class="n">Theta_hats</span><span class="o">.</span><span class="n">values</span><span class="p">()][</span><span class="n">t</span><span class="p">]</span> <span class="k">for</span> <span class="n">predictor</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">predictors</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span> <span class="c1"># get CURRENT day&#39;s precision matrices (at time t!)</span>
    <span class="k">if</span> <span class="n">const_theta</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_predictors</span><span class="p">):</span>
            <span class="n">theta_params</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">Theta_hats_t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="c1"># set the value of the cvxpy parameters to the current precision matrices</span>
        <span class="n">w_opt</span> <span class="o">=</span> <span class="n">max_log_likelihood_const_theta</span><span class="p">(</span><span class="n">prob</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">theta_params</span><span class="p">,</span> <span class="n">R_temp</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">set_of_Theta_hats</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">predictor</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">predictors</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">Theta_hats_temp</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="n">predictor</span><span class="o">.</span><span class="n">Theta_hats</span><span class="o">.</span><span class="n">values</span><span class="p">()][</span><span class="n">t</span><span class="o">-</span><span class="p">(</span><span class="n">likelihood_window</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span><span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">set_of_Theta_hats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Theta_hats_temp</span><span class="p">)</span>
        <span class="n">precisions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">set_of_Theta_hats</span><span class="p">),</span> <span class="p">(</span><span class="n">likelihood_window</span><span class="p">,</span> <span class="n">n_predictors</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
        <span class="n">w_opt</span> <span class="o">=</span> <span class="n">max_log_likelihood</span><span class="p">(</span><span class="n">precisions</span><span class="p">,</span> <span class="n">R_temp</span><span class="p">)</span>


    <span class="n">Theta_hat_opt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">w_opt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">Theta_hats_t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">w_opt</span><span class="p">)))</span>

    <span class="k">return</span> <span class="n">w_opt</span><span class="p">,</span> <span class="n">Theta_hat_opt</span></div>

    <span class="c1">##### Can probably remove this code below #####</span>
    <span class="c1"># for predictor in model.predictors.values():</span>
    <span class="c1">#     Theta_hats_temp = [*predictor.Theta_hats.values()][t-(likelihood_window+1):t-1] # Don&#39;t include t; avoid look-ahead bias</span>
    <span class="c1">#     set_of_Theta_hats.append(Theta_hats_temp) </span>

    <span class="c1"># precisions = np.reshape(np.array(set_of_Theta_hats), (likelihood_window, n_predictors, n, n))</span>

    <span class="c1"># return max_log_likelihood(precisions, R_temp)</span>

    <span class="c1"># set_of_Theta_hats = np.array(set_of_Theta_hats).reshape(likelihood_window, n_predictors, n**2) # batch_size, n_predictors, n, n</span>

    <span class="c1"># weighted_Theta_hats = []</span>
    <span class="c1"># for i in range(likelihood_window):</span>
    <span class="c1">#     Theta_vec = cp.sum(cp.multiply(w, set_of_Theta_hats[i]), axis=0)</span>
    <span class="c1">#     weighted_Theta_hats.append(cp.reshape(Theta_vec, (n,n)))</span>


    <span class="c1"># # Compute the log likelihood (ignore the constant terms)</span>
    <span class="c1"># log_likelihood = cp.sum([cp_get_log_likelihood(R_temp[i], weighted_Theta_hats[i]) for i in range(likelihood_window)])</span>

    <span class="c1"># obj = cp.Maximize(log_likelihood)</span>
    <span class="c1"># cons = [cp.sum(w)==1, w&gt;=0]</span>
    <span class="c1"># if w_init is not None:</span>
    <span class="c1">#     const += [cp.norm(w-w_init, 2) &lt;= 0.1]</span>
    <span class="c1"># prob = cp.Problem(obj, cons)</span>

    <span class="c1"># prob.solve(solver=&quot;MOSEK&quot;)</span>
    <span class="c1"># w_opt = w.value</span>

    <span class="c1"># theta = np.array([w_opt[i]*set_of_Theta_hats[-1][i].reshape(n,n) for i in range(n_predictors)]).sum(axis=0)</span>

    <span class="c1"># return w_opt, theta</span>




<div class="viewcode-block" id="get_realized_covs"><a class="viewcode-back" href="../../autoapi/covariance/utils/index.html#covariance.utils.get_realized_covs">[docs]</a><span class="k">def</span> <span class="nf">get_realized_covs</span><span class="p">(</span><span class="n">R</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    param R: numpy array where rows are vector of asset returns for t=0,1,...</span>
<span class="sd">        R has shape (T, n) where T is the number of days and n is the number of assets</span>

<span class="sd">    returns: (numpy array) list of r_t*r_t&#39; (matrix multiplication) for all days, i.e,</span>
<span class="sd">        &quot;daily realized covariances&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">R</span> <span class="o">@</span> <span class="n">R</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span></div>
    

<div class="viewcode-block" id="get_realized_vars"><a class="viewcode-back" href="../../autoapi/covariance/utils/index.html#covariance.utils.get_realized_vars">[docs]</a><span class="k">def</span> <span class="nf">get_realized_vars</span><span class="p">(</span><span class="n">R</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    param R: numpy array where rows are vector of asset returns for t=0,1,...</span>
<span class="sd">        R has shape (T, n) where T is the number of days and n is the number of assets</span>

<span class="sd">    returns: (numpy array) list of diag(r_t^2) for all days, i.e,\</span>
<span class="sd">        &quot;daily realized variances&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">variances</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">r_t</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,)</span>
        <span class="n">variances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">r_t</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">variances</span><span class="p">)</span></div>

<div class="viewcode-block" id="from_cov_to_corr"><a class="viewcode-back" href="../../autoapi/covariance/utils/index.html#covariance.utils.from_cov_to_corr">[docs]</a><span class="k">def</span> <span class="nf">from_cov_to_corr</span><span class="p">(</span><span class="n">Sigma</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    returns correlation matrix R corresponding to covariance matrix Sigma</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">Sigma</span><span class="p">))</span>
    <span class="n">outer_V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
    <span class="n">corr</span> <span class="o">=</span> <span class="n">Sigma</span> <span class="o">/</span> <span class="n">outer_V</span>
    <span class="k">return</span> <span class="n">corr</span></div>

<div class="viewcode-block" id="get_realized_sizes"><a class="viewcode-back" href="../../autoapi/covariance/utils/index.html#covariance.utils.get_realized_sizes">[docs]</a><span class="k">def</span> <span class="nf">get_realized_sizes</span><span class="p">(</span><span class="n">R</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    param R: numpy array where rows are vector of asset returns for t=0,1,...</span>
<span class="sd">        R has shape (T, n) where T is the number of days and n is the number of assets</span>

<span class="sd">        returns: (numpy array) list of r_t^Tr_t for all days (t), i.e,</span>
<span class="sd">            &quot;daily realized sizes&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sizes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">r_t</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r_t</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">r_t</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sizes</span><span class="p">)</span></div>

<div class="viewcode-block" id="get_next_ewma"><a class="viewcode-back" href="../../autoapi/covariance/utils/index.html#covariance.utils.get_next_ewma">[docs]</a><span class="k">def</span> <span class="nf">get_next_ewma</span><span class="p">(</span><span class="n">EWMA</span><span class="p">,</span> <span class="n">y_last</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">beta</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    param EWMA: EWMA at time t-1</span>
<span class="sd">    param y_last: observation at time t-1</span>
<span class="sd">    param t: current time step</span>
<span class="sd">    param beta: EWMA exponential forgetting parameter</span>

<span class="sd">    returns: EWMA estimate at time t (note that this does not depend on y_t)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">old_weight</span> <span class="o">=</span> <span class="p">(</span><span class="n">beta</span><span class="o">-</span><span class="n">beta</span><span class="o">**</span><span class="n">t</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">beta</span><span class="o">**</span><span class="n">t</span><span class="p">)</span>
    <span class="n">new_weight</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">beta</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">beta</span><span class="o">**</span><span class="n">t</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">old_weight</span><span class="o">*</span><span class="n">EWMA</span> <span class="o">+</span> <span class="n">new_weight</span><span class="o">*</span><span class="n">y_last</span></div>

<div class="viewcode-block" id="get_ewmas"><a class="viewcode-back" href="../../autoapi/covariance/utils/index.html#covariance.utils.get_ewmas">[docs]</a><span class="k">def</span> <span class="nf">get_ewmas</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">T_half</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    y: array with measurements for times t=1,2,...,T=len(y)</span>
<span class="sd">    T_half: EWMA half life</span>

<span class="sd">    returns: list of EWMAs for times t=2,3,...,T+1 = len(y)</span>


<span class="sd">    Note: We define EWMA_t as a function of the </span>
<span class="sd">    observations up to time t-1. This means that</span>
<span class="sd">    y = [y_1,y_2,...,y_T] (for some T), while</span>
<span class="sd">    EWMA = [EWMA_2, EWMA_3, ..., EWMA_{T+1}]</span>
<span class="sd">    This way we don&#39;t get a &quot;look-ahead bias&quot; in the EWMA</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">beta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">T_half</span><span class="p">)</span>
    <span class="n">EWMA_t</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">EWMAs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span> <span class="c1"># First EWMA is for t=2 </span>
        <span class="n">y_last</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># Note zero-indexing</span>
        <span class="n">EWMA_t</span> <span class="o">=</span> <span class="n">get_next_ewma</span><span class="p">(</span><span class="n">EWMA_t</span><span class="p">,</span> <span class="n">y_last</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>
        <span class="n">EWMAs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">EWMA_t</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">EWMAs</span><span class="p">)</span></div>

<div class="viewcode-block" id="get_r_tildes"><a class="viewcode-back" href="../../autoapi/covariance/utils/index.html#covariance.utils.get_r_tildes">[docs]</a><span class="k">def</span> <span class="nf">get_r_tildes</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Ws</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    param Ws: array of whitening matrices for t=1,2,..., (i.e. L^t, where LL^T=Sigma^-1)</span>
<span class="sd">    param R: array of returns to whiten for t=1,2,..., </span>

<span class="sd">    returns numpy array with r_tilde_hats as rows</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Ws</span> <span class="o">@</span> <span class="n">R</span></div>

<div class="viewcode-block" id="get_cholesky"><a class="viewcode-back" href="../../autoapi/covariance/utils/index.html#covariance.utils.get_cholesky">[docs]</a><span class="k">def</span> <span class="nf">get_cholesky</span><span class="p">(</span><span class="n">Sigma_hats</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    returns: Cholesky (transpose) decomposition of Sigma_hat^-1 for each Sigma_hat in Sigma_hats, i.e.,</span>
<span class="sd">        LL^T = Sigma_hat^-1;</span>
<span class="sd">        Note: returns L^T</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Lts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">Sigma_hats</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">Sigma_hat</span> <span class="ow">in</span> <span class="n">Sigma_hats</span><span class="p">:</span>
        <span class="n">Sigma_hat_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">Sigma_hat</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">Sigma_hat_inv</span><span class="p">)</span>
        <span class="n">Lts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Lts</span><span class="p">)</span></div>

<span class="c1">####### I think the folloiwng functions are not used anymore, but let&#39;s keep them for now ########</span>

<div class="viewcode-block" id="get_log_likelihood"><a class="viewcode-back" href="../../autoapi/covariance/utils/index.html#covariance.utils.get_log_likelihood">[docs]</a><span class="k">def</span> <span class="nf">get_log_likelihood</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Sigma</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    param x: numpy array of shape (n,1)</span>
<span class="sd">    param Sigma: numpy array of shape (n,n)</span>
<span class="sd">    param mu: numpy array of shape (n,1)</span>
<span class="sd">        if None, mu is set to zero vector</span>

<span class="sd">    returns: log-likelihood of x under multivariate normal distribution</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">Sigma</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">mu</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Sigma</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">det</span> <span class="o">=</span> <span class="n">Sigma</span>
        <span class="n">Sigma_inv</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">Sigma</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">det</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="n">Sigma_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">Sigma</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="o">-</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">det</span><span class="p">)</span> <span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">mu</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">Sigma_inv</span><span class="o">@</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">mu</span><span class="p">))</span></div>



<div class="viewcode-block" id="get_avg_likelihood"><a class="viewcode-back" href="../../autoapi/covariance/utils/index.html#covariance.utils.get_avg_likelihood">[docs]</a><span class="k">def</span> <span class="nf">get_avg_likelihood</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Sigma_hats</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    returns: (averaged) log-likelihood of observed returns R, under the Gaussian distribution</span>
<span class="sd">        with mean zero and covariances in Sigma_hats</span>

<span class="sd">    param R: rows are n-dimensinal return vectors for times t=1,...,T</span>
<span class="sd">    param Sigma_hats: array-like vector of corresponding covariance matrices</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">daily_likelihoods</span> <span class="o">=</span> <span class="n">get_daily_likelihood</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Sigma_hats</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">daily_likelihoods</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_daily_likelihood"><a class="viewcode-back" href="../../autoapi/covariance/utils/index.html#covariance.utils.get_daily_likelihood">[docs]</a><span class="k">def</span> <span class="nf">get_daily_likelihood</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Sigma_hats</span><span class="p">,</span> <span class="n">in_parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    returns: log-likelihood of observed returns R, under the Gaussian distribution</span>
<span class="sd">        with mean zero and covariances in Sigma_hats</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># n assets</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>

    <span class="n">log_likelihoods</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">in_parallel</span><span class="p">:</span>
        <span class="c1"># Compute log-likelihood for each day in parallel</span>
        <span class="n">pool</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">Pool</span><span class="p">()</span>
        <span class="n">log_likelihoods</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">get_log_likelihood</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Sigma_hats</span><span class="p">))</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">log_likelihoods</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Compute log-likelihood for each day sequentially</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">r_t</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="n">t</span><span class="p">,:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">Sigma_hat_t</span> <span class="o">=</span> <span class="n">Sigma_hats</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
            <span class="n">log_likelihoods</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">get_log_likelihood</span><span class="p">(</span><span class="n">r_t</span><span class="p">,</span> <span class="n">Sigma_hat_t</span><span class="p">,</span> <span class="n">mu</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">log_likelihoods</span><span class="p">)</span></div>
        
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright .</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>